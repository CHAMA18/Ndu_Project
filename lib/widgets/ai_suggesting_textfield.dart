import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:ndu_project/openai/openai_config.dart';
import 'package:ndu_project/services/openai_service_secure.dart';
import 'package:ndu_project/utils/project_data_helper.dart';
import 'package:ndu_project/utils/text_sanitizer.dart';

/// Debouncer utility to limit API calls while typing
class _Debouncer {
  _Debouncer({Duration? delay})
      : delay = delay ?? const Duration(milliseconds: 400);
  final Duration delay;
  Timer? _timer;
  void run(void Function() action) {
    _timer?.cancel();
    _timer = Timer(delay, action);
  }

  void dispose() => _timer?.cancel();
}

/// A text field with inline OpenAI-powered suggestions
/// - Shows suggestion chips beneath the field
/// - Suggestions are based on current text and prior project context
class AiSuggestingTextField extends StatefulWidget {
  const AiSuggestingTextField({
    super.key,
    required this.fieldLabel,
    required this.hintText,
    required this.sectionLabel,
    this.showLabel = true,
    this.enableAi = true,
    this.autoGenerate = false,
    this.autoGenerateSection,
    this.autoGenerateMaxTokens = 900,
    this.autoGenerateTemperature = 0.5,
    this.onAutoGenerated,
    this.onChanged,
    this.initialText,
    this.onRegenerate,
    this.onUndo,
    this.canUndo = false,
  });

  final String fieldLabel;
  final String hintText;
  final String sectionLabel;
  final bool showLabel;
  final bool enableAi;
  final bool autoGenerate;
  final String? autoGenerateSection;
  final int autoGenerateMaxTokens;
  final double autoGenerateTemperature;
  final ValueChanged<String>? onAutoGenerated;
  final ValueChanged<String>? onChanged;
  final String? initialText;
  final VoidCallback? onRegenerate;
  final VoidCallback? onUndo;
  final bool canUndo;

  @override
  State<AiSuggestingTextField> createState() => _AiSuggestingTextFieldState();
}

class _AiSuggestingTextFieldState extends State<AiSuggestingTextField> {
  static const int _basicPlanAiLimit = 2;
  final TextEditingController _controller = TextEditingController();
  final FocusNode _focusNode = FocusNode();
  final _debouncer = _Debouncer();
  List<String> _suggestions = const [];
  bool _loading = false;
  String? _error;
  bool _autoGenerated = false;
  bool _autoGenerating = false;
  bool _isReplaceMode = false;
  bool _isHovering = false;

  String get _aiUsageKey {
    final section = (widget.autoGenerateSection?.trim().isNotEmpty ?? false)
        ? widget.autoGenerateSection!.trim()
        : widget.sectionLabel.trim();
    return section.toLowerCase();
  }

  bool get _isBasicPlanProject {
    return ProjectDataHelper.getData(context).isBasicPlanProject;
  }

  int get _aiUsageCount {
    final data = ProjectDataHelper.getData(context);
    return data.aiUsageCounts[_aiUsageKey] ?? 0;
  }

  int get _remainingAiUses {
    if (!_isBasicPlanProject) return _basicPlanAiLimit;
    final remaining = _basicPlanAiLimit - _aiUsageCount;
    return remaining < 0 ? 0 : remaining;
  }

  bool get _isNotesField {
    final text = [
      widget.fieldLabel,
      widget.hintText,
      widget.sectionLabel,
      widget.autoGenerateSection ?? '',
    ].join(' ');
    return RegExp(r'\\bnotes?\\b', caseSensitive: false).hasMatch(text);
  }

  bool get _aiEnabled => widget.enableAi && !_isNotesField;

  bool get _aiLimitReached => _isBasicPlanProject && _remainingAiUses <= 0;

  bool get _showLastChanceNote => _isBasicPlanProject && _remainingAiUses == 1;

  void _recordAiUsage() {
    if (!_isBasicPlanProject) return;
    final provider = ProjectDataHelper.getProvider(context);
    provider.updateField((data) {
      final counts = Map<String, int>.from(data.aiUsageCounts);
      final current = counts[_aiUsageKey] ?? 0;
      final next = current + 1;
      counts[_aiUsageKey] = next > _basicPlanAiLimit ? _basicPlanAiLimit : next;
      return data.copyWith(aiUsageCounts: counts);
    });
    setState(() {});
  }

  @override
  void initState() {
    super.initState();
    if ((widget.initialText ?? '').isNotEmpty) {
      _controller.text = TextSanitizer.sanitizeAiText(widget.initialText);
    }
    _controller.addListener(_onTextChanged);
    if (_aiEnabled && widget.autoGenerate) {
      WidgetsBinding.instance.addPostFrameCallback((_) => _maybeAutoGenerate());
    }
  }

  @override
  void dispose() {
    _controller.removeListener(_onTextChanged);
    _controller.dispose();
    _focusNode.dispose();
    _debouncer.dispose();
    super.dispose();
  }

  void _onTextChanged() {
    widget.onChanged?.call(_controller.text);
    if (!_aiEnabled) return;
    _debouncer.run(() async {
      await _fetchSuggestions();
    });
  }

  Future<void> _maybeAutoGenerate() async {
    if (!_aiEnabled) return;
    if (_autoGenerated || _autoGenerating) return;
    if (_controller.text.trim().isNotEmpty) return;
    if (_aiLimitReached) return;

    final section = widget.autoGenerateSection?.trim().isNotEmpty == true
        ? widget.autoGenerateSection!.trim()
        : widget.sectionLabel.trim();
    final data = ProjectDataHelper.getData(context);
    final sectionLower = section.toLowerCase();
    final useExecutiveContext = sectionLower.contains('executive') ||
        sectionLower.contains('execution plan');
    final contextText = useExecutiveContext
        ? ProjectDataHelper.buildExecutivePlanContext(data,
            sectionLabel: section)
        : ProjectDataHelper.buildFepContext(data, sectionLabel: section);
    if (contextText.trim().isEmpty) return;

    _autoGenerating = true;
    try {
      final ai = OpenAiServiceSecure();
      final text = await ai.generateFepSectionText(
        section: section,
        context: contextText,
        maxTokens: widget.autoGenerateMaxTokens,
        temperature: widget.autoGenerateTemperature,
      );
      if (!mounted) return;
      _recordAiUsage();
      if (_controller.text.trim().isEmpty && text.trim().isNotEmpty) {
        _controller.text = TextSanitizer.sanitizeAiText(text);
        _controller.selection = TextSelection.fromPosition(
          TextPosition(offset: _controller.text.length),
        );
        widget.onChanged?.call(_controller.text);
        widget.onAutoGenerated?.call(_controller.text);
      }
    } finally {
      _autoGenerated = true;
      _autoGenerating = false;
    }
  }

  Future<void> _fetchSuggestions() async {
    if (!_aiEnabled) return;
    final text = _controller.text.trim();
    if (text.isEmpty) {
      setState(() {
        _suggestions = const [];
        _error = null;
      });
      return;
    }
    if (_aiLimitReached) {
      setState(() {
        _suggestions = const [];
        _error = null;
      });
      return;
    }

    final data = ProjectDataHelper.getData(context);
    final sectionLower = widget.sectionLabel.toLowerCase();
    final useExecutiveContext = sectionLower.contains('executive') ||
        sectionLower.contains('execution plan');
    final contextText = useExecutiveContext
        ? ProjectDataHelper.buildExecutivePlanContext(data,
            sectionLabel: widget.sectionLabel)
        : ProjectDataHelper.buildFepContext(data,
            sectionLabel: widget.sectionLabel);

    setState(() {
      _loading = true;
      _error = null;
    });

    try {
      final items = await OpenAiAutocompleteService.instance.fetchSuggestions(
        fieldName: widget.fieldLabel,
        currentText: text,
        context: contextText,
        maxSuggestions: 4,
      );
      if (!mounted) return;
      setState(() {
        _suggestions =
            items.map((s) => TextSanitizer.sanitizeAiText(s)).toList();
        _loading = false;
      });
      _recordAiUsage();
    } catch (e) {
      if (!mounted) return;
      setState(() {
        // Check if OpenAI is configured
        if (!OpenAiConfig.isConfigured) {
          _error =
              'OpenAI API key not configured. Please add your API key to enable AI suggestions.';
        } else {
          final warn = OpenAiConfig.configurationWarning();
          _error = warn ?? e.toString();
        }
        _loading = false;
      });
    }
  }

  void _applySuggestion(String suggestion) {
    final sanitized = TextSanitizer.sanitizeAiText(suggestion);
    
    if (_isReplaceMode) {
      // Replace entire field content
      _controller.text = sanitized;
      _controller.selection = TextSelection.fromPosition(
          TextPosition(offset: _controller.text.length));
    } else {
      // Insert at cursor position
      final current = _controller.text;
      final selection = _controller.selection;
      final beforeCursor = current.substring(0, selection.baseOffset);
      final afterCursor = current.substring(selection.extentOffset);
      final needsSpace = beforeCursor.isNotEmpty && 
          !beforeCursor.endsWith('\n') && 
          !beforeCursor.endsWith(' ') &&
          !beforeCursor.endsWith('.');
      final next = beforeCursor + 
          (needsSpace ? ' ' : '') + 
          sanitized + 
          afterCursor;
      _controller.text = next;
      final newOffset = selection.baseOffset + (needsSpace ? 1 : 0) + sanitized.length;
      _controller.selection = TextSelection.fromPosition(
          TextPosition(offset: newOffset));
    }
    widget.onChanged?.call(_controller.text);
  }

  Future<void> _copyToClipboard(String suggestion) async {
    await Clipboard.setData(ClipboardData(text: suggestion));
    
    // Auto-paste into active field
    _applySuggestion(suggestion);
    
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Copied and pasted to field'),
          duration: Duration(seconds: 2),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (widget.showLabel) ...[
          Text(
            widget.fieldLabel,
            style: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w600,
              color: Color(0xFF111827),
            ),
          ),
          const SizedBox(height: 14),
        ],
        MouseRegion(
          onEnter: (_) => setState(() => _isHovering = true),
          onExit: (_) => setState(() => _isHovering = false),
          child: Stack(
            children: [
              TextField(
                controller: _controller,
                focusNode: _focusNode,
                maxLines: 12,
                minLines: 8,
                decoration: InputDecoration(
                  hintText: widget.hintText,
                  hintStyle:
                      const TextStyle(color: Color(0xFF9CA3AF), fontSize: 14),
                  contentPadding:
                      const EdgeInsets.symmetric(horizontal: 20, vertical: 20),
                  filled: true,
                  fillColor: Colors.white,
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(16),
                    borderSide: const BorderSide(color: Color(0xFFE5E7EB)),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(16),
                    borderSide:
                        const BorderSide(color: Color(0xFFFFD700), width: 1.6),
                  ),
                  suffixIcon: _aiEnabled
                      ? (_autoGenerating
                          ? const Padding(
                              padding: EdgeInsets.all(12.0),
                              child: SizedBox(
                                  width: 20,
                                  height: 20,
                                  child:
                                      CircularProgressIndicator(strokeWidth: 2)),
                            )
                          : Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                if (_isHovering && widget.onRegenerate != null)
                                  IconButton(
                                    tooltip: 'Regenerate this field',
                                    icon: const Icon(Icons.refresh, size: 18),
                                    color: const Color(0xFF2563EB),
                                    onPressed: widget.onRegenerate,
                                    padding: EdgeInsets.zero,
                                    constraints: const BoxConstraints(
                                      minWidth: 32,
                                      minHeight: 32,
                                    ),
                                  ),
                                if (_isHovering && widget.onUndo != null && widget.canUndo)
                                  IconButton(
                                    tooltip: 'Undo last change',
                                    icon: const Icon(Icons.undo, size: 18),
                                    color: const Color(0xFF6B7280),
                                    onPressed: widget.onUndo,
                                    padding: EdgeInsets.zero,
                                    constraints: const BoxConstraints(
                                      minWidth: 32,
                                      minHeight: 32,
                                    ),
                                  ),
                                IconButton(
                                  tooltip: 'AI suggest',
                                  icon: _loading
                                      ? const SizedBox(
                                          width: 20,
                                          height: 20,
                                          child: CircularProgressIndicator(
                                              strokeWidth: 2))
                                      : const Icon(Icons.auto_awesome,
                                          color: Color(0xFFF59E0B)),
                                  onPressed: (_loading || _aiLimitReached)
                                      ? null
                                      : _fetchSuggestions,
                                ),
                              ],
                            ))
                      : null,
                ),
                style: const TextStyle(
                    fontSize: 14, color: Color(0xFF111827), height: 1.5),
              ),
            ],
          ),
        ),
        if (_aiEnabled && _autoGenerating && !_autoGenerated) ...[
          const SizedBox(height: 8),
          Row(
            children: [
              const SizedBox(
                  width: 16,
                  height: 16,
                  child: CircularProgressIndicator(strokeWidth: 2)),
              const SizedBox(width: 8),
              Text(
                'AI is generating content...',
                style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey[600],
                    fontStyle: FontStyle.italic),
              ),
            ],
          ),
        ],
        if (_aiEnabled && _isBasicPlanProject && _aiLimitReached) ...[
          const SizedBox(height: 10),
          _AiLimitBanner(
            message:
                'AI suggestions are not available for this section on the Basic plan.',
            background: const Color(0xFFF3F4F6),
            border: const Color(0xFFE5E7EB),
            textColor: const Color(0xFF6B7280),
          ),
        ] else if (_aiEnabled && _showLastChanceNote) ...[
          const SizedBox(height: 10),
          const _AiLimitBanner(
            message: 'AI KAZ is available to assist one last time.',
            background: Color(0xFFFFF7ED),
            border: Color(0xFFFCD34D),
            textColor: Color(0xFF92400E),
          ),
        ],
        const SizedBox(height: 10),
        if ((_error ?? '').isNotEmpty)
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
            margin: const EdgeInsets.only(bottom: 8),
            decoration: BoxDecoration(
              color: const Color(0xFFFEF2F2),
              borderRadius: BorderRadius.circular(10),
              border: Border.all(color: const Color(0xFFFCA5A5)),
            ),
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Icon(Icons.warning_amber_rounded,
                    size: 18, color: Color(0xFFB91C1C)),
                const SizedBox(width: 10),
                Expanded(
                  child: Text(
                    _error!,
                    style: const TextStyle(
                        fontSize: 13, color: Color(0xFFB91C1C), height: 1.4),
                  ),
                ),
              ],
            ),
          ),
        if (_aiEnabled && _suggestions.isNotEmpty) ...[
          Row(
            children: [
              const Text(
                'Mode:',
                style: TextStyle(fontSize: 12, color: Color(0xFF6B7280)),
              ),
              const SizedBox(width: 8),
              Switch(
                value: _isReplaceMode,
                onChanged: (value) => setState(() => _isReplaceMode = value),
                materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
              ),
              const SizedBox(width: 4),
              Text(
                _isReplaceMode ? 'Replace All' : 'Insert at Cursor',
                style: const TextStyle(fontSize: 12, color: Color(0xFF6B7280)),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: _suggestions
                .map((s) => ActionChip(
                      backgroundColor: const Color(0xFFE1EEFF),
                      shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(999)),
                      label: Text(
                        s,
                        style: const TextStyle(
                            fontSize: 12,
                            fontWeight: FontWeight.w600,
                            color: Color(0xFF1F2937)),
                      ),
                      avatar: const Icon(Icons.add_rounded,
                          size: 16, color: Color(0xFF1F2937)),
                      onPressed: () => _applySuggestion(s),
                    ))
                .toList(),
          ),
        ],
      ],
    );
  }
}

class _AiLimitBanner extends StatelessWidget {
  const _AiLimitBanner({
    required this.message,
    required this.background,
    required this.border,
    required this.textColor,
  });

  final String message;
  final Color background;
  final Color border;
  final Color textColor;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: background,
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: border),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(Icons.info_outline, size: 18, color: textColor),
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              message,
              style: TextStyle(fontSize: 13, color: textColor, height: 1.4),
            ),
          ),
        ],
      ),
    );
  }
}
